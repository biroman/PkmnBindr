rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Enhanced role checking functions
    function getUserRole(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)) ?
             get(/databases/$(database)/documents/users/$(userId)).data.get('role', 'user') : 'user';
    }

    // Role hierarchy helper
    function getRoleLevel(role) {
      return role == 'owner' ? 4 :
             role == 'admin' ? 3 :
             role == 'moderator' ? 2 :
             1; // user
    }

    // Check if user has a specific role or higher
    function hasRole(userId, requiredRole) {
      let userRole = getUserRole(userId);
      return getRoleLevel(userRole) >= getRoleLevel(requiredRole);
    }

    // Helper function to check if user is owner
    function isOwner(userId) {
      return hasRole(userId, 'owner');
    }

    // Helper function to check if user is admin or owner  
    function isAdmin(userId) {
      return hasRole(userId, 'admin');
    }

    // Helper function to check if user is moderator or higher
    function isModerator(userId) {
      return hasRole(userId, 'moderator');
    }

    // Check if user has specific permission (simplified - could be expanded)
    function hasPermission(userId, permission) {
      let userRole = getUserRole(userId);
      // Owner has all permissions
      if (userRole == 'owner') return true;
      // Admin permissions
      if (userRole == 'admin') {
        return permission in ['manage_users', 'view_all_binders', 'manage_system_config', 'view_analytics', 'manage_rules'];
      }
      // Moderator permissions  
      if (userRole == 'moderator') {
        return permission in ['moderate_content', 'view_user_reports', 'manage_announcements'];
      }
      // User permissions
      return permission in ['manage_own_binders', 'create_binder', 'view_public_binders', 'contact_support'];
    }

    // Helper function to validate string length
    function isValidStringLength(str, maxLength) {
      return str is string && str.size() <= maxLength;
    }

    // Helper function to validate number range
    function isValidNumberRange(num, min, max) {
      return num is number && num >= min && num <= max;
    }

    // Helper function to check if system is in emergency mode
    function isEmergencyMode() {
      return exists(/databases/$(database)/documents/systemMonitoring/currentUsage) &&
             get(/databases/$(database)/documents/systemMonitoring/currentUsage).data.keys().hasAll(['emergencyMode']) &&
             get(/databases/$(database)/documents/systemMonitoring/currentUsage).data.emergencyMode == true;
    }

    // System Monitoring - only owners can write, read restricted
    match /systemMonitoring/{docId} {
      allow read: if request.auth != null && isOwner(request.auth.uid);
      allow write: if request.auth != null && isOwner(request.auth.uid);
    }

    // System Configuration - only owners can write, anyone can read
    match /systemConfiguration/{configId} {
      allow read: if true;  // Everyone needs to read limits
      allow write: if request.auth != null && isOwner(request.auth.uid);
    }

    // Users collection - allow owners to read for admin purposes
    match /users/{userId} {
      // Block operations if in emergency mode (except for owners)
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid); // Owners can always access
      
      // PUBLIC PROFILE ACCESS: Allow any authenticated user to read basic profile info
      allow read: if !isEmergencyMode() && request.auth != null;
      
      // Enhanced data validation for user profile updates
      allow update: if request.auth != null && 
                       request.auth.uid == userId &&
                       !isEmergencyMode() &&
                       // Validate displayName length (max 50 chars)
                       (!('displayName' in resource.data) || 
                        !('displayName' in request.resource.data) ||
                        isValidStringLength(request.resource.data.displayName, 50)) &&
                       // Validate email format (basic check)
                       (!('email' in resource.data) || 
                        !('email' in request.resource.data) ||
                        (isValidStringLength(request.resource.data.email, 100) && 
                         request.resource.data.email.matches('.*@.*\\..*'))) &&
                       // Validate banner color (max 200 chars, must be valid CSS color/gradient)
                       (!('bannerColor' in request.resource.data) ||
                        (isValidStringLength(request.resource.data.bannerColor, 200) &&
                         (request.resource.data.bannerColor.matches('^#[0-9a-fA-F]{3,8}$') ||
                          request.resource.data.bannerColor.matches('^linear-gradient\\(.*\\)$') ||
                          request.resource.data.bannerColor.matches('^radial-gradient\\(.*\\)$') ||
                          request.resource.data.bannerColor.matches('^rgb\\(.*\\)$') ||
                          request.resource.data.bannerColor.matches('^rgba\\(.*\\)$') ||
                          request.resource.data.bannerColor.matches('^hsl\\(.*\\)$') ||
                          request.resource.data.bannerColor.matches('^hsla\\(.*\\)$')))) &&
                       // Validate favoriteBinders array (max 100 favorites)
                       (!('favoriteBinders' in request.resource.data) ||
                        (request.resource.data.favoriteBinders is list &&
                         request.resource.data.favoriteBinders.size() <= 100)) &&
                       // Validate role cannot be changed by user (unless they don't have one yet)
                       (!('role' in resource.data) || 
                        !('role' in request.resource.data) ||
                        resource.data.role == request.resource.data.role);
    }

    // User subcollections - keep private to user only with enhanced validation
    match /users/{userId}/binders/{binderId} {
      // Block operations if in emergency mode (except for owners)
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
      
      // Enhanced validation for binder creation/updates
      allow create, update: if request.auth != null && 
                               request.auth.uid == userId &&
                               !isEmergencyMode() &&
                               // Validate binder name (required, max 100 chars)
                               request.resource.data.keys().hasAll(['binderName']) &&
                               isValidStringLength(request.resource.data.binderName, 100) &&
                               // Validate description (max 500 chars if present)
                               (!('description' in request.resource.data) ||
                                isValidStringLength(request.resource.data.description, 500)) &&
                               // Validate pageCount (1-200 range)
                               (!('pageCount' in request.resource.data) ||
                                isValidNumberRange(request.resource.data.pageCount, 1, 200)) &&
                               // Validate maxPages (1-200 range)
                               (!('maxPages' in request.resource.data) ||
                                isValidNumberRange(request.resource.data.maxPages, 1, 200)) &&
                               // Validate gridSize (specific values only)
                               (!('gridSize' in request.resource.data) ||
                                request.resource.data.gridSize in ['1x1', '2x2', '3x3', '3x4', '4x4']);
    }

    // User cards subcollection with strict validation
    match /users/{userId}/binders/{binderId}/cards/{cardId} {
      // Block operations if in emergency mode (except for owners)
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
      
      // Enhanced validation for card creation/updates
      allow create, update: if request.auth != null && 
                               request.auth.uid == userId &&
                               !isEmergencyMode() &&
                               // Validate required fields
                               request.resource.data.keys().hasAll(['cardApiId', 'name']) &&
                               // Validate card name (max 100 chars)
                               isValidStringLength(request.resource.data.name, 100) &&
                               // Validate cardApiId (max 50 chars)
                               isValidStringLength(request.resource.data.cardApiId, 50) &&
                               // Validate value if present (0-999999 range)
                               (!('value' in request.resource.data) ||
                                isValidNumberRange(request.resource.data.value, 0, 999999)) &&
                               // Validate pageNumber if present (1-200 range)
                               (!('pageNumber' in request.resource.data) ||
                                isValidNumberRange(request.resource.data.pageNumber, 1, 200)) &&
                               // Validate slotInPage if present (0-35 range for max 6x6 grid)
                               (!('slotInPage' in request.resource.data) ||
                                isValidNumberRange(request.resource.data.slotInPage, 0, 35));
    }

    // User activity subcollection - allow users to delete their own activity when deleting account
    match /users/{userId}/activity/{activityId} {
      allow read, delete: if request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid); // Owners can manage activity logs
      // Users cannot write to activity logs directly (only server-side operations)
    }

    // User collections subcollection
    match /users/{userId}/collections/{collectionId} {
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
      
      // Validate collection data
      allow create, update: if request.auth != null && 
                               request.auth.uid == userId &&
                               !isEmergencyMode() &&
                               // Validate name (required, max 100 chars)
                               request.resource.data.keys().hasAll(['name']) &&
                               isValidStringLength(request.resource.data.name, 100) &&
                               // Validate description (max 500 chars if present)
                               (!('description' in request.resource.data) ||
                                isValidStringLength(request.resource.data.description, 500));
    }

    // User preferences subcollection (NEW - was missing)
    match /users/{userId}/preferences/{preferenceId} {
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
    }

    // User wishlist subcollection
    match /users/{userId}/wishlist/{wishlistId} {
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && request.auth.uid == userId;
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
      
      // Validate wishlist data
      allow create, update: if request.auth != null && 
                               request.auth.uid == userId &&
                               !isEmergencyMode() &&
                               // Validate name (required, max 100 chars)
                               request.resource.data.keys().hasAll(['name']) &&
                               isValidStringLength(request.resource.data.name, 100) &&
                               // Validate itemType
                               request.resource.data.itemType in ['card', 'binder'] &&
                               // Validate maxPrice if present (0-999999 range)
                               (!('maxPrice' in request.resource.data) ||
                                isValidNumberRange(request.resource.data.maxPrice, 0, 999999));
    }

    // Binders collection - Global binder collection (for admin queries)
    match /binders/{binderId} {
      // Users can only access their own binders
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && 
                                   resource.data.ownerId == request.auth.uid;
      // Owners can access all binders (for admin purposes)
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
      
      // Allow reading public binders
      allow read: if resource.data.permissions.public == true;
    }

    // User Binders collection - for the new sync service
    match /user_binders/{docId} {
      // Block operations if in emergency mode (except for owners)
      allow read, write, delete: if !isEmergencyMode() && request.auth != null && 
                           docId.matches('^' + request.auth.uid + '_.*');
      allow read, write, delete: if request.auth != null && isOwner(request.auth.uid);
      
      // Allow collection queries where ownerId equals current user
      allow list: if !isEmergencyMode() && request.auth != null && 
                     resource.data.ownerId == request.auth.uid;
      
      // PUBLIC BINDER ACCESS: Allow reading public binders by any authenticated user
      allow read: if !isEmergencyMode() && request.auth != null && 
                     resource.data.permissions.public == true;
      
      // ANONYMOUS SHARE ACCESS: Allow anonymous reading of public binders via valid share links
      allow read: if resource.data.permissions.public == true &&
                     exists(/databases/$(database)/documents/shared_binders/$(request.query.shareId)) &&
                     get(/databases/$(database)/documents/shared_binders/$(request.query.shareId)).data.isActive == true &&
                     get(/databases/$(database)/documents/shared_binders/$(request.query.shareId)).data.binderId == resource.data.id;
      
      // Allow querying public binders by any authenticated user
      allow list: if !isEmergencyMode() && request.auth != null && 
                     request.query.filters.hasAny([
                       ['permissions.public', '==', true]
                     ]);
      
      // BINDER INTERACTIONS: Allow authenticated users to like and favorite public binders
      // Allow interaction updates (likes, favorites, views) on public binders
      allow update: if !isEmergencyMode() && 
                       request.auth != null && 
                       resource.data.permissions.public == true &&
                       // Only allow updating interaction fields
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly([
                         'likes', 'likeCount', 
                         'favoriteUsers', 'favoriteCount', 
                         'views', 'viewCount', 
                         'lastViewed', 'lastInteraction', 'updatedAt'
                       ]);
      
      // Enhanced validation for binder creation/updates
      allow create, update: if request.auth != null && 
                               docId.matches('^' + request.auth.uid + '_.*') &&
                               !isEmergencyMode() &&
                               // Validate required fields
                               request.resource.data.keys().hasAll(['id', 'ownerId']) &&
                               request.resource.data.ownerId == request.auth.uid &&
                               // Validate binder name (max 100 chars if present)
                               (!('metadata' in request.resource.data) ||
                                !('name' in request.resource.data.metadata) ||
                                isValidStringLength(request.resource.data.metadata.name, 100)) &&
                               // Validate description (max 500 chars if present)
                               (!('metadata' in request.resource.data) ||
                                !('description' in request.resource.data.metadata) ||
                                isValidStringLength(request.resource.data.metadata.description, 500)) &&
                               // Validate version (must be number)
                               (!('version' in request.resource.data) ||
                                request.resource.data.version is number) &&
                               // Validate grid size (specific values only)
                               (!('settings' in request.resource.data) ||
                                !('gridSize' in request.resource.data.settings) ||
                                request.resource.data.settings.gridSize in ['2x2', '3x3', '4x3', '4x4']) &&
                               // Validate permissions structure
                               (!('permissions' in request.resource.data) ||
                                (request.resource.data.permissions.keys().hasAll(['public']) &&
                                 request.resource.data.permissions.public is bool));
    }

    // Global Rules collection - Owner can manage, users can read
    match /globalRules/{ruleId} {
      // Owner has full access to create, read, update, delete rules
      allow read, write: if request.auth != null && isOwner(request.auth.uid);
      
      // All authenticated users can read rules (needed to check what rules apply to them)
      allow read: if request.auth != null;
    }

    // Rule Usage collection - Users can read their own usage, owner can read all
    match /ruleUsage/{usageId} {
      // Users can read their own usage records
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      
      // Users can create their own usage records (for tracking)
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.userId &&
                       request.resource.data.keys().hasAll(['userId', 'ruleId', 'resource']) &&
                       isValidStringLength(request.resource.data.ruleId, 50) &&
                       isValidStringLength(request.resource.data.resource, 50);
      
      // Users can update their own usage records (for tracking)
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.userId &&
                       request.auth.uid == request.resource.data.userId;
      
      // Owner can read all usage records (for analytics)
      allow read: if request.auth != null && isOwner(request.auth.uid);
      
      // Owner can write usage records (for management and cleanup)
      allow write: if request.auth != null && isOwner(request.auth.uid);
    }

    // Contact System Collections
    
    // Direct Messages - Users can read/write their own threads, owners can access all
    match /directMessages/{userId} {
      // Users can read/write their own message thread
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Owners can read/write all message threads (for admin purposes)
      allow read, write: if request.auth != null && isOwner(request.auth.uid);
      
      // Subcollection for individual messages
      match /messages/{messageId} {
        // Users can read/write messages in their own thread
        allow read, write: if request.auth != null && request.auth.uid == userId;
        
        // Owners can read/write all messages (for admin replies)
        allow read, write: if request.auth != null && isOwner(request.auth.uid);
        
        // Validate message content on create/update with rate limiting
        allow create, update: if request.auth != null && 
                                 request.resource.data.keys().hasAll(['senderId', 'text']) &&
                                 (request.resource.data.senderId == request.auth.uid || 
                                  request.resource.data.senderId == 'admin') &&
                                 isValidStringLength(request.resource.data.text, 2000) &&
                                 // Rate limiting: allow admin messages without restriction, limit user messages
                                 (request.resource.data.senderId == 'admin' || 
                                  (!exists(/databases/$(database)/documents/ruleUsage/$(request.auth.uid + '_direct_messages')) ||
                                   get(/databases/$(database)/documents/ruleUsage/$(request.auth.uid + '_direct_messages')).data.get('count', 0) < 5));
      }
    }
    
    // Feature Requests - Users can create and read their own, owners can access all
    match /featureRequests/{requestId} {
      // Users can read their own feature requests
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      
      // Users can create feature requests with rate limiting
      allow create: if request.auth != null && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'userName', 'title', 'description', 'status', 'upvotes']) &&
                       isValidStringLength(request.resource.data.title, 100) &&
                       isValidStringLength(request.resource.data.description, 1000) &&
                       request.resource.data.status == 'received' &&
                       request.resource.data.upvotes == 0 &&
                       // Rate limiting: max 3 feature requests per day
                       (!exists(/databases/$(database)/documents/ruleUsage/$(request.auth.uid + '_feature_requests')) ||
                        get(/databases/$(database)/documents/ruleUsage/$(request.auth.uid + '_feature_requests')).data.get('count', 0) < 3);
      
      // Owners can read/write all feature requests (for management)
      allow read, write: if request.auth != null && isOwner(request.auth.uid);
    }
    
    // Bug Reports - Users can create and read their own, owners can access all
    match /bugReports/{reportId} {
      // Users can read their own bug reports
      allow read: if request.auth != null && request.auth.uid == resource.data.userId;
      
      // Users can create bug reports with rate limiting
      allow create: if request.auth != null && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'userName', 'title', 'description', 'status', 'priority']) &&
                       isValidStringLength(request.resource.data.title, 100) &&
                       isValidStringLength(request.resource.data.description, 1000) &&
                       request.resource.data.status == 'new' &&
                       request.resource.data.priority in ['low', 'medium', 'high'] &&
                       // Rate limiting: max 10 bug reports per day
                       (!exists(/databases/$(database)/documents/ruleUsage/$(request.auth.uid + '_bug_reports')) ||
                        get(/databases/$(database)/documents/ruleUsage/$(request.auth.uid + '_bug_reports')).data.get('count', 0) < 10);
      
      // Owners can read/write all bug reports (for management)
      allow read, write: if request.auth != null && isOwner(request.auth.uid);
    }

    // Announcements/Changelog - Users can read published, owners can manage all
    match /announcements/{announcementId} {
      // Owners have full access to all announcements
      allow read, write, create, update, delete, list: if request.auth != null && isOwner(request.auth.uid);
      
      // All authenticated users can read and list published announcements
      allow read, list: if request.auth != null && 
                           (resource == null || resource.data.isPublished == true);
    }

    // User upload rate limiting - for profile picture uploads
    match /userUploadLimits/{userId} {
      // Users can read their own upload limits
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Users can create/update their own upload tracking (managed by client)
      allow write: if request.auth != null && 
                      request.auth.uid == userId &&
                      request.resource.data.keys().hasAll(['uploads', 'lastReset', 'canUpload']) &&
                      request.resource.data.uploads is number &&
                      request.resource.data.uploads >= 0 &&
                      request.resource.data.uploads <= 10 && // Max 10 for safety buffer
                      request.resource.data.lastReset is timestamp &&
                      request.resource.data.canUpload is bool;
      
      // Owners can read/write all upload limits (for management)
      allow read, write: if request.auth != null && isOwner(request.auth.uid);
    }

    // Conversations - Direct messaging system between admin and users
    // SECURITY: Role-based access control for conversations
    match /conversations/{conversationId} {
      // Users can read conversations they participate in
      allow read: if request.auth != null && 
        (resource.data.userId == request.auth.uid || 
         (resource.data.adminId == request.auth.uid && isAdmin(request.auth.uid)));
      
      // Only admins can create conversations
      allow create: if request.auth != null && 
        isAdmin(request.auth.uid) && 
        request.resource.data.adminId == request.auth.uid &&
        request.resource.data.keys().hasAll(['id', 'adminId', 'userId', 'adminName', 'userName', 'participants']);
      
      // Participants can update conversation metadata (like read status)
      allow update: if request.auth != null && 
        (resource.data.userId == request.auth.uid || 
         (resource.data.adminId == request.auth.uid && isAdmin(request.auth.uid))) &&
        // Prevent changing core conversation structure
        resource.data.id == request.resource.data.id &&
        resource.data.adminId == request.resource.data.adminId &&
        resource.data.userId == request.resource.data.userId;
      
      // Only admins can delete conversations
      allow delete: if request.auth != null && 
        isAdmin(request.auth.uid) && 
        resource.data.adminId == request.auth.uid;
      
      // Admins can list all their conversations, users can list theirs
      allow list: if request.auth != null && 
        (isAdmin(request.auth.uid) || 
         // This will be filtered server-side for users
         request.auth != null);
      
      // Messages within conversations - strict access control
      match /messages/{messageId} {
        // Only conversation participants can read messages
        allow read: if request.auth != null && 
          (get(/databases/$(database)/documents/conversations/$(conversationId)).data.userId == request.auth.uid ||
           (get(/databases/$(database)/documents/conversations/$(conversationId)).data.adminId == request.auth.uid && 
            isAdmin(request.auth.uid)));
        
        // Only conversation participants can create messages
        allow create: if request.auth != null && 
          (get(/databases/$(database)/documents/conversations/$(conversationId)).data.userId == request.auth.uid ||
           (get(/databases/$(database)/documents/conversations/$(conversationId)).data.adminId == request.auth.uid && 
            isAdmin(request.auth.uid))) &&
          request.resource.data.senderId == request.auth.uid &&
          request.resource.data.keys().hasAll(['senderId', 'message', 'isAdmin']);
        
        // Messages cannot be modified or deleted after creation (audit trail)
        allow update, delete: if false;
        
        // Participants can list messages in their conversations
        allow list: if request.auth != null && 
          (get(/databases/$(database)/documents/conversations/$(conversationId)).data.userId == request.auth.uid ||
           (get(/databases/$(database)/documents/conversations/$(conversationId)).data.adminId == request.auth.uid && 
            isAdmin(request.auth.uid)));
      }
    }

    // Binder interactions collection - for likes and favorites
    match /binderInteractions/{interactionId} {
      // Users can read/write their own interactions
      allow read, write: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Allow reading interactions for public binders (for stats)
      allow read: if request.auth != null;
    }

    // Binder card customizations collection - separate from binder content
    match /binderCardCustomizations/{customizationId} {
      // Users can read their own customizations
      allow read: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Users can create their own customizations
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId &&
        request.resource.data.keys().hasAll(['binderId', 'userId']) &&
        customizationId == (request.resource.data.userId + '_' + request.resource.data.binderId);
      
      // Users can update their own customizations
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.userId &&
        request.auth.uid == request.resource.data.userId;
      
      // Users can delete their own customizations
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
      
      // Allow reading customizations for public binders (so others can see the card design)
      allow read: if request.auth != null;
    }

    // Messages collection - users can read/write their own messages
    match /messages/{messageId} {
      allow read, write: if request.auth != null && 
        (request.auth.uid == resource.data.senderId || 
         request.auth.uid == resource.data.recipientId);
    }

    // Admin collection - only owners and admins can access
    match /admin/{document=**} {
      allow read, write: if request.auth != null && isAdmin(request.auth.uid);
    }

    // User activity tracking
    match /userActivity/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Public profiles - readable by authenticated users
    match /publicProfiles/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }

    // Shared Binders collection - for shareable links
    match /shared_binders/{shareId} {
      // ANONYMOUS READ ACCESS: Allow anonymous users to read active shares
      allow read: if resource.data.isActive == true;
      
      // AUTHENTICATED READ ACCESS: Allow authenticated users to read active shares
      allow read: if request.auth != null && resource.data.isActive == true;
      
      // CREATE: Only authenticated users can create shares for their own binders
      allow create: if request.auth != null && 
                       request.auth.uid == request.resource.data.ownerId &&
                       !isEmergencyMode() &&
                       // Validate required fields
                       request.resource.data.keys().hasAll(['shareId', 'binderId', 'ownerId', 'isActive']) &&
                       request.resource.data.shareId == shareId &&
                       isValidStringLength(request.resource.data.shareId, 20) &&
                       isValidStringLength(request.resource.data.binderId, 50) &&
                       request.resource.data.isActive == true &&
                       // Validate settings if present
                       (!('settings' in request.resource.data) ||
                        (request.resource.data.settings.keys().hasAll(['allowAnonymous']) &&
                         request.resource.data.settings.allowAnonymous is bool)) &&
                       // Validate customSlug if present (must be unique and valid format)
                       (!('settings' in request.resource.data) ||
                        !('customSlug' in request.resource.data.settings) ||
                        (request.resource.data.settings.customSlug == null ||
                         (isValidStringLength(request.resource.data.settings.customSlug, 50) &&
                          request.resource.data.settings.customSlug.matches('^[a-z0-9-]{3,50}$')))) &&
                       // Validate analytics structure
                       (!('analytics' in request.resource.data) ||
                        (request.resource.data.analytics.keys().hasAll(['totalViews', 'uniqueVisitors']) &&
                         request.resource.data.analytics.totalViews == 0 &&
                         request.resource.data.analytics.uniqueVisitors is list &&
                         request.resource.data.analytics.uniqueVisitors.size() == 0));
      
      // UPDATE: Only owner can update their shares (for analytics and deactivation)
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.ownerId &&
                       request.auth.uid == request.resource.data.ownerId &&
                       !isEmergencyMode() &&
                       // Prevent changing core identifiers
                       resource.data.shareId == request.resource.data.shareId &&
                       resource.data.binderId == request.resource.data.binderId &&
                       resource.data.ownerId == request.resource.data.ownerId;
      
      // DELETE: Only owner can delete their shares
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.ownerId &&
                       !isEmergencyMode();
      
      // LIST: Allow listing for owners (to manage their shares)
      allow list: if request.auth != null && 
                     resource.data.ownerId == request.auth.uid;
      
      // LIST: Allow admins to list all shares
      allow list: if request.auth != null && isOwner(request.auth.uid);
    }

    // Deny all other collections/documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
